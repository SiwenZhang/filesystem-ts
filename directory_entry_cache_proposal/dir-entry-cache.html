<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Directory Entry Caching</title>
<style>
body
{
  font-family: arial, sans-serif;
  max-width: 6.75in;
  margin: 0px auto;
  font-size: 85%;
}
 ins  {background-color: #CCFFCC; text-decoration: none;}
 del  {background-color: #FFCACA; text-decoration: none;}
 pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
 code {font-family: "courier new", courier, serif;}
 table {font-size: 90%;}
</style>
</head>

<body>

<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color: #FFFF00">D0317R0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-04-27<!--webbot bot="Timestamp" endspan i-checksum="12278" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library</td>
</tr>
</table>

<h1 align="center">Directory Entry Caching for Filesystem (R0)</h1>


<p align="center"><b>Fixing issue 
<a href="https://cplusplus.github.io/LWG/lwg-active.html#2663">2663</a>, <i>Enable efficient retrieval 
of file size from <code>directory_entry</code><br> </i>and issue
<a href="http://cplusplus.github.io/LWG/lwg-active.html#2677">2677</a>, <i>
<code>directory_entry::status</code> is not allowed to be cached ...</i></b></p>


  <p style="margin-left:20%; margin-right:20%;">This paper provides two 
  proposals for solving the problem of efficiently caching state information 
  obtained during directory iteration. Guidance is sought as to which proposal 
  is preferred by the library and library evolution working groups.</p>


  <p style="margin-left:20%; margin-right:20%;">Both proposals include full 
  wording, have been implemented, and avoid use of mutable data members. Both 
  offer guidance to users on how to use cached information when desired or avoid 
  use of cached information when not desired, without exposing to the user 
  whether information is actually cached. Both allow the user to write code that 
  is fully portable between&nbsp; implementations that cache or do not cache.</p>


  <p style="margin-left:20%; margin-right:20%;">One proposal exposes what 
  directory state information may possibly be cached, and so would require 
  additions to the standard to extend the interface to accommodate future 
  operating systems or file systems that supply additional state information on 
  directory iteration. </p>


  <p style="margin-left:20%; margin-right:20%;">The other proposal does not 
  expose what directory state information may possibly be cached, and so 
  requires no changes to the standard as operating systems and file systems 
  evolve. But this proposal may be harder to reason about. It depends on 
  automatic conversions, already part of the interface, which may cause some 
  people to worry about unintended consequences.</p>


  <h2><a name="Introduction">Introduction</a></h2>

  <p>Directory iteration in real-world operating systems always returns directory 
  entry information containing file name. POSIX includes file status as an 
  option, but only some POSIX-like operating system enable this. Windows always 
  includes file status, 
  file size, and last modification date. Accessing the additional 
  information from the directory entry is much more efficient than re-accessing 
  the file system to obtain the information.</p>

  <p>The initial filesystem TS proposal
  <span style="background-color: #FFFF00">(need reference)</span> and the Boost 
  Filesystem implementation limited the additional information stored by class
  <code>directory_entry</code> to the regular status and symlink status, since these were the 
  only additional elements common to several operating systems. The caching of 
  this additional information was described using mutable exposition-only 
  data members. The LWG removed the mutable members and associated caching 
  wording because mutable members are problematic and race prone in 
  multi-threaded environments. The original design also exposed too many implementation 
  details and was not easily extendible to additional cache information such as 
  file size and last write timestamp.</p>

  <p>LWG issue <a href="http://cplusplus.github.io/LWG/lwg-active.html#2663">2663</a>, <i>Enable efficient retrieval of file size from </i><code><i>directory_entry</i></code>, 
  requests that for Windows caching be extended to file size.</p>

  <p>LWG issue
<a href="http://cplusplus.github.io/LWG/lwg-active.html#2677">2677</a>, <i>
<code>directory_entry::status</code> is not allowed to be cached as a 
  quality-of-implementation issue</i>, requests the reinstatement of permission 
  for implementations to cache directory entry information.</p>

  <h2>Design</h2>

  <p>As a convenience for users, class <code>directory_entry</code> 
  already has an implicit conversion to <code>path</code>:</p>

  <blockquote>
    <p><code>operator const path&amp;() const noexcept;</code></p>
</blockquote>

    <p>This means that the following two function calls are equivalent:</p>

  <blockquote>

    <p><code>sz = file_size(my_directory_entry);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    // call #1<br>
    sz = file_size(my_directory_entry.path());&nbsp; // call #2</code></p>

  </blockquote>

    <p>Both would currently call the non-member function:</p>

  <blockquote>

    <p><code>uintmax_t file_size(const path&amp; p);</code></p>

  </blockquote>

    <p>But if there were a second signature: </p>

  <blockquote>

    <p><code>uintmax_t file_size(const directory_entry&amp; d);</code></p>

  </blockquote>

    <p>It would be invoked by call #1, and the implementation could provide the 
    file size from information cached in <code>d</code>. Guidance to users would 
    be to use call #1 when the possibly cached&nbsp; <code>directory_entry</code> file size is desired, 
    use call #2 when file size from a file system access is desired. For 
    implementations where file size is not cached in directory 
    entries, both call forms access the file system to obtain the file size.</p>

    <h3>Background</h3>

    <p>For Windows, <code>directory_entry</code> information is obtained by calling function
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx">
      FindFirstFile</a>,
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364419(v=vs.85).aspx">
      FindFirstFileEx</a>, 
      or 
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx">
      FindNextFile</a>, which return pointers to structure
      
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365740(v=vs.85).aspx">
      WIN32_FIND_DATA</a>, and can be refreshed by calling function
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364952(v=vs.85).aspx">
      GetFileInformationByHandle</a> 
      which returns a pointer to structure
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788(v=vs.85).aspx">
      BY_HANDLE_FILE_INFORMATION</a>.</p>

    <p>For some POSIX-like systems, such as
    <a href="http://man7.org/linux/man-pages/man3/readdir.3.html">Linux</a> and 
    some BSD-based distributions, glibc versions since 2.19 may support an 
    additional <code>struct dirent</code> field named <code>d_type</code> 
    &quot;making it possible to avoid the expense of calling <code>lstat</code>&quot;. 
    POSIX specifies that the macro <code>_DIRENT_HAVE_D_TYPE</code> is defined 
    if <code>d_type</code> is present.</p>

    <h3>Specification options</h3>

    <p>There are two possible ways to specify the above behavior; (1) require the <code>const 
    directory_entry&amp;</code> overload for all operational functions that 
    might possibly benefit from it, either now and in the future, or (2) provide 
    overall wording to encourage the implementation to supply the <code>const 
    directory_entry&amp;</code> overload where applicable, but make no changes 
    to the specifications of individual operational functions .</p>

    <p>The 
    difficulty with option (1) is that it essentially doubles the number of 
    operational function signatures, making the operational functions harder to 
    learn, even though few of these added signatures will do anything more than 
    forward to the <code>const path&amp;</code>&nbsp; signature. Option (2) 
    segregates what is essentially an experts-only feature into its own separate 
    specification, and is what is being proposed below.</p>

  <h2>Proposed wording</h2>

  <p><span style="background-color: #FFFF00"><i>Separate &lt;del&gt; wording from 
  &lt;ins&gt; wording. Moving forward now on the removal wording and later on the 
  &lt;ins&gt; wording would allow time to be sure the &lt;ins&gt; wording is fully baked.</i></span></p>

<h2>27.10.12  <a name="Class-directory_entry">Class <code>directory_entry</code></a> [class.directory_entry]</h2>

<pre>namespace std::filesystem {
  class directory_entry {
  public:
    // <a href="#directory_entry-constructors">constructors</a> and destructor
    directory_entry() noexcept = default;
    directory_entry(const directory_entry&amp;) = default;
    directory_entry(directory_entry&amp;&amp;) noexcept = default;
    explicit directory_entry(const path&amp; p);
    <ins>directory_entry(const path&amp; p, error_code& ec);</ins>
   ~directory_entry();

    // <a href="#directory_entry-modifiers">modifiers</a>
    directory_entry&amp; operator=(const directory_entry&amp;) = default;
    directory_entry&amp; operator=(directory_entry&amp;&amp;) noexcept = default;
    void assign(const path&amp; p);
    <ins>void assign(const path&amp; p, error_code&amp; ec);</ins>
    <ins>void refresh();</ins>
    <ins>void refresh(error_code&amp; ec) noexcept;</ins>
    void replace_filename(const path&amp; p);

    // <a href="#directory_entry-observers">observers</a>
    const path&amp;  path() const noexcept;
    operator const path&amp;() const noexcept;
    <del>file_status  status() const;</del>
    <del>file_status  status(error_code&amp; ec) const noexcept;</del>
    <del>file_status  symlink_status() const;</del>
    <del>file_status  symlink_status(error_code&amp; ec) const noexcept;</del>

    bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
    bool operator==(const directory_entry&amp; rhs) const noexcept;
    bool operator!=(const directory_entry&amp; rhs) const noexcept;
    bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
    bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
    bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;
  private:
    path   m_path; // for exposition only
  };

}</pre>
<p>A <code>directory_entry</code> object stores a <code>path</code> object.</p>
<p><ins>Implementations are permitted and encouraged to cache additional information 
about the state of external 
storage in <code>directory_entry</code> 
objects if such information is available during directory iteration and caching 
it would improve efficiency of  operational query functions ([fs.op.funcs]). 
Implementations are permitted and encouraged to overload  operational query functions that take <code>const path&amp;</code> arguments with 
additional signatures taking <code>const directory_entry&amp;</code> arguments. 
Such overloads shall be equivalent to ([structure.specifications]) the <code>const path&amp;</code> 
overload of the function except that state information shall be obtained from the <code>directory_entry</code> 
argument&#39;s 
cache rather than the external file system.</ins></p>
<p><ins>[<i>Note: </i>Users wishing to make use of cached <code>directory_entry</code> 
state information should call status and other operational query functions 
using the <code>directory_entry</code> object as an argument. Users wishing to 
ensure that an operational function returns the most recent available 
information should call the function with a <code>path</code> object or an 
object that is convertible to <code>path</code>. —<i>end note</i>]</ins></p>
<p><ins>[<i>Note: </i>Operational query functions that may benefit from caching 
include <code>status</code>, <code>symlink_status</code>, <code>exists</code>,
<code>is_block_file</code>, <code>is_character_file</code>, i<code>s_directory</code>,
<code>is_fifo</code>, <code>is_other</code>, <code>is_regular_file</code>, <code>
is_socket</code>, <code>is_symlink</code>, <code>status_known</code>, <code>
last_write_time</code>, and <code>file_size</code>.&nbsp; —<i>end note</i>]</ins></p>
<p><ins><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Example: TBS
</span> </i><span style="background-color: #FFFF00">—<i>end 
example</i>]</span></ins></p>
<h3>27.10.12.1 <a name="directory_entry-constructors"><code>directory_entry</code> 
constructors </a>[directory_entry.cons] </h3>
<pre>explicit directory_entry(const path&amp; p);
<ins>directory_entry(const path&amp; p, error_code& ec);</ins></pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type <code>directory_entry</code><ins>, 
  then <code>refresh(<i>[ec]</i>)</code></ins>.
  </p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<h3>27.10.12.2 <a name="directory_entry-modifiers"><code>directory_entry</code> 
modifiers </a>[directory_entry.mods] </h3>
<pre>void assign(const path&amp; p);
<ins>void assign(const path&amp; p, error_code&amp; ec);</ins></pre>
<blockquote>
  <p><ins><i>Effects:</i> <code>refresh(<i>[ec]</i>)</code>.</ins></p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<pre><ins>void refresh();</ins>
<ins>void refresh(error_code&amp; ec) noexcept;</ins></pre>
<blockquote>
<p><ins><i>Effects:</i> Stores current values for the 
attributes of
the file <code>p</code> resolves to in the additional information cache, if 
any.</ins></p>
<p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<pre>void replace_filename(const path&amp; p);</pre>
<blockquote>
  <p><i>Postcondition:</i> <code>path() == x.parent_path() / p</code> where <code>x</code> is the value of <code>path()</code> before the function is 
  called. </p>
</blockquote>
</blockquote>
<h3>27.10.12.3 <a name="directory_entry-observers"><code>directory_entry</code> observers </a>[directory_entry.obs] </h3>
<pre>const path&amp; path() const noexcept;
operator const path&amp;() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path</code> </p>
</blockquote>
<pre><del>file_status status() const;</del>
<del>file_status status(error_code&amp; ec) const noexcept;</del></pre>
<blockquote>
  <p><del><i>Returns:</i> <code>status(path()<i>[, ec]</i>)</code></del>. </p>
  <p para_num="5"><del><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</del></p>
</blockquote>
<pre para_num="6"><del>file_status  symlink_status() const;</del>
<del>file_status  symlink_status(error_code&amp; ec) const noexcept;</del></pre>
<blockquote>
   <p para_num="7"><del><i>Returns:</i> <code>symlink_status(path()<i>[, ec]</i>)</code>.</del></p>
  <p para_num="8"><del><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</del></p>
</blockquote>
<pre para_num="9">bool operator==(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="10"><i>Returns:</i> <code>m_path == rhs.m_path</code>. </p>
</blockquote>
<pre para_num="11">bool operator!=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="12"><i>Returns:</i> <code>m_path != rhs.m_path</code>. </p>
</blockquote>
<pre para_num="13">bool operator&lt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="14"><i>Returns:</i> <code>m_path &lt; rhs.m_path</code>. </p>
</blockquote>
<pre para_num="15">bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="16"><i>Returns:</i> <code>m_path &lt;= rhs.m_path</code>. </p>
</blockquote>
<pre para_num="17">bool operator&gt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="18"><i>Returns:</i> <code>m_path &gt; rhs.m_path</code>. </p>
</blockquote>
<pre para_num="19">bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="20"><i>Returns:</i> <code>m_path &gt;= rhs.m_path</code>. </p>
</blockquote>


  <h2><a name="References">References</a></h2>


  <p>[1] Issue 2663, C++ Standard Library Issues Lists,
  <a href="https://cplusplus.github.io/LWG/lwg-active.html#2663">
  cplusplus.github.io/LWG/lwg-active.html#2663</a></p>

<p>[2] N4582, Working Draft, Standard for Programming Language C++, 2016,
<a class="uri" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf</a></p>

<p>[<a name="1">3</a>] Beman Dawes, N4100, Programming Languages — C++ — File System Technical Specification, 
2014.<br>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf" class="uri">
www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf</a></p>
<p>[<a name="2">4</a>] Beman Dawes, others, <a href="http://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm">Boost Filesystem Library, V3</a>, 2015.<br>
<a href="https://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm" class="uri">
www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm</a></p>

<hr>

</pre></body>

</html>