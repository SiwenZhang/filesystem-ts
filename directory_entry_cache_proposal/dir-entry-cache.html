<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Directory Entry Caching</title>
<style>
body
{
  font-family: arial, sans-serif;
  max-width: 6.75in;
  margin: 0px auto;
  font-size: 85%;
}
 ins  {background-color: #CCFFCC; text-decoration: none;}
 del  {background-color: #FFCACA; text-decoration: none;}
 pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
 code {font-family: "courier new", courier, serif;}
 table {font-size: 90%; border-collapse: collapse;}
</style>
</head>

<body>

<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color: #FFFF00">D0317R0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-04-15<!--webbot bot="Timestamp" endspan i-checksum="12273" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library</td>
</tr>
</table>

<h1 align="center">Directory Entry Caching for Filesystem (R0)</h1>


<p align="center"><b>Fixing issue 
<a href="https://cplusplus.github.io/LWG/lwg-active.html#2663">2663</a>, <i>Enable efficient retrieval 
of file size from <code>directory_entry</code><br> </i>and issue
<a href="http://cplusplus.github.io/LWG/lwg-active.html#2677">2677</a>, <i>
<code>directory_entry::status</code> is not allowed to be cached ...</i></b></p>


  <p style="margin-left:20%; margin-right:20%;">This paper proposes a new design for efficiently caching 
  state information obtained during directory iteration. No implementation details are 
  exposed beyond the fact that there may be a cache. Implementations may cache 
  directory entry state information without any need 
  for changes in user code or the standard library. The design makes minimal 
  changes to existing interfaces and implementations. The proposed wording offers clear guidance 
  to users as to how to make use of cached information when desired or avoid use of cached 
  information when not desired, without the user having to know whether any  information is 
  actually cached. The proposal has been implemented.</p>


  <h2><a name="Introduction">Introduction</a></h2>

  <p>Directory iteration in real-world operating systems returns directory 
  entries containing file name plus additional information such as file status, 
  size, and last modification date. Exactly what additional information is 
  returned varies between operating systems. Accessing the additional 
  information from the directory entry is much more efficient than re-accessing 
  the file system to obtain the information.</p>

  <p>The initial filesystem TS proposal
  <span style="background-color: #FFFF00">(need reference)</span> and the Boost 
  Filesystem implementation limited the additional information stored in a 
  directory entry to the regular status and symlink status, since these were the 
  only additional elements common to several operating systems. The caching of 
  this additional information was described using mutable exposition-only 
  members. The LWG removed the mutable members and associated caching wording 
  because mutable members are problematic and race prone in multi-threaded 
  environments. In retrospect, that original design also exposed too many implementation 
  details and was not easily extendible to additional cache information such as 
  file size and last write timestamp.</p>

  <p>LWG issue 2663, <i>[filesys.ts] Enable efficient retrieval of 
  file size from </i><code><i>directory_entry</i></code>, requests that for 
  Windows caching be extended to file size. Although this request was made 
  before the LWG removed caching, it is indicative of the desire to maximize 
  efficiency for particular operating systems. Subsequent to the removal of 
  directory entry caching and addition of Filesystem to the standard library, a
  <span style="background-color: #FFFF00">new issue</span> has been submitted 
  asking for the reinstatement of caching.</p>

  <h2>Design</h2>

  <p>As a convenience for users, class <code>directory_entry</code> 
  already has an implicit conversion to <code>path</code>:</p>

  <blockquote>
    <p><code>operator const path&amp;() const noexcept;</code></p>
</blockquote>

    <p>This means that the following two function calls are equivalent:</p>

  <blockquote>

    <p><code>sz = file_size(my_directory_entry);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    // call #1<br>
    sz = file_size(my_directory_entry.path());&nbsp; // call #2</code></p>

  </blockquote>

    <p>Both would currently call the non-member function:</p>

  <blockquote>

    <p><code>uintmax_t file_size(const path&amp; p);</code></p>

  </blockquote>

    <p>But if there were a second signature: </p>

  <blockquote>

    <p><code>uintmax_t file_size(const directory_entry&amp; d);</code></p>

  </blockquote>

    <p>It would be invoked by call #1, and the implementation could provide the 
    file size from information cached in <code>d</code>. Guidance to users would 
    be to use call #1 when the possibly cached&nbsp; <code>directory_entry</code> file size is desired, 
    use call #2 when file size from a file system access is desired. For 
    implementations where file size is not cached in directory 
    entries, both call forms access the file system to obtain the file size.</p>

    <h3>Background</h3>

    <p>For Windows, <code>directory_entry</code> information is obtained by calling function
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx">
      FindFirstFile</a>,
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364419(v=vs.85).aspx">
      FindFirstFileEx</a>, 
      or 
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx">
      FindNextFile</a>, which return pointers to structure
      
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365740(v=vs.85).aspx">
      WIN32_FIND_DATA</a>, and can be refreshed by calling function
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364952(v=vs.85).aspx">
      GetFileInformationByHandle</a> 
      which returns a pointer to structure
      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788(v=vs.85).aspx">
      BY_HANDLE_FILE_INFORMATION</a>.</p>

    <p>For some POSIX-like systems, such as
    <a href="http://man7.org/linux/man-pages/man3/readdir.3.html">Linux</a> and 
    some BSD-based distributions, glibc versions since 2.19 may support an 
    additional <code>struct dirent</code> field named <code>d_type</code> 
    &quot;making it possible to avoid the expense of calling <code>lstat</code>&quot;. 
    POSIX specifies that the macro <code>_DIRENT_HAVE_D_TYPE</code> is defined 
    if <code>d_type</code> is present.</p>

    <h3>Specification options</h3>

    <p>There are two possible ways to specify the above behavior; (1) require the <code>const 
    directory_entry&amp;</code> overload for all operational functions that 
    might possibly benefit from it, either now and in the future, or (2) provide 
    overall wording to encourage the implementation to supply the <code>const 
    directory_entry&amp;</code> overload where applicable, but make no changes 
    to the specifications of individual operational functions .</p>

    <p>The 
    difficulty with option (1) is that it essentially doubles the number of 
    operational function signatures, making the operational functions harder to 
    learn, even though few of these added signatures will do anything more than 
    forward to the <code>const path&amp;</code>&nbsp; signature. Option (2) 
    segregates what is essentially an experts-only feature into its own separate 
    specification, and is what is being proposed below.</p>

<h2>Proposed wording - Option 1</h2>

<h2>27.10.12  <a name="Class-directory_entry">Class <code>directory_entry</code></a> [class.directory_entry]</h2>

<pre>namespace std::filesystem {
  class directory_entry {
  public:
    // <a href="#directory_entry-constructors">constructors</a> and destructor
    directory_entry() noexcept = default;
    directory_entry(const directory_entry&amp;) = default;
    directory_entry(directory_entry&amp;&amp;) noexcept = default;
    explicit directory_entry(const path&amp; p);
    <ins>directory_entry(const path&amp; p, error_code& ec);</ins>
   ~directory_entry();

    // <a href="#directory_entry-modifiers">modifiers</a>
    directory_entry&amp; operator=(const directory_entry&amp;) = default;
    directory_entry&amp; operator=(directory_entry&amp;&amp;) noexcept = default;
    void assign(const path&amp; p);
    <ins>void assign(const path&amp; p, error_code&amp; ec);</ins>
    <ins>void refresh();</ins>
    <ins>void refresh(error_code&amp; ec) noexcept;</ins>
    void replace_filename(const path&amp; p);

    // <a href="#directory_entry-observers">observers</a>
    const path&amp;  path() const noexcept;
    operator const path&amp;() const noexcept;
    <ins>uintmax_t file_size() const;</ins>
    <ins>uintmax_t file_size(error_code&amp; ec) const noexcept;</ins>
    <ins>file_time_type last_write_time()const;</ins>
    <ins>file_time_type last_write_time(error_code&amp; ec)const noexcept;</ins>
    file_status  status() const;
    file_status  status(error_code&amp; ec) const noexcept;>
    file_status  symlink_status() const;
    file_status  symlink_status(error_code&amp; ec) const noexcept;

    bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
    bool operator==(const directory_entry&amp; rhs) const noexcept;
    bool operator!=(const directory_entry&amp; rhs) const noexcept;
    bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
    bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
    bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;
  private:
    path            m_path;              // for exposition only
    <ins>uintmax_t       m_file_size;         // for exposition only</ins>
    <ins>file_time_type  m_last_write_time;   // for exposition only</ins>
    <ins>file_status     m_status;            // for exposition only</ins>
    <ins>file_status     m_symlink_status;    // for exposition only</ins>
  };

}</pre>

<p>A <code>directory_entry</code> object stores a <code>path</code> object.</p>

<p><ins>Implementations are encouraged to provide each data member in the following table
iff its equivalent value is available during directory iteration without actually having
to call the function from the Equivalent Value column. Otherwise implementations
shall not provide the data member.
</ins></p>

<table border="1" align="center">
  <tr>
    <td colspan="2" align="center"><ins><b>Possibly Cached Values</b></ins></td>
  </tr>
  <tr>
    <td align="center"><ins><b>Data member</b></ins></td>
    <td align="center"><ins><b>Equivalent Value</b></ins></td>
  </tr>
  <tr>
    <td><ins><code>m_file_size</code></ins></td>
    <td><ins><code>std::filesystem::file_size(this->path())</code></ins></td>
  </tr>
  <tr>
    <td><ins><code>m_last_write_time</code></ins></td>
    <td><ins><code>std::filesystem::last_write_time(this->path())</code></ins></td>
  </tr>
  <tr>
    <td><ins><code>m_status</code></ins></td>
    <td><ins><code>std::filesystem::status(this->path())</code></ins></td>
  </tr>
  <tr>
    <td><ins><code>m_symlink_status</code></ins></td>
    <td><ins><code>std::filesystem::symlink_status(this->path())</code></ins></td>
  </tr>
</table>

<p><ins>[<i>Example:</i><br/><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto iter = directory_iterator(".");</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>...<br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_regular_file(iter-&gt;status()) // #1</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_regular_file(iter-&gt;path()) &nbsp;&nbsp;// #2</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_regular_file(*iter)
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// #3</code><br/><br/>

Expression #1 will call <code>is_regular_file</code> with the value of <code>m_status</code>
 if provided, otherwise it will call <code>is_regular_file</code> with the value returned
 by <code>std::filesystem::status(itr-&gt;path())</code>.<br/><br/>

Expressions #2 and #3
 will always call <code>is_regular_file</code> with the value returned
 by <code>std::filesystem::status(itr-&gt;path())</code> regardless of whether or not
 <code>m_status</code> is provided.
  &mdash;<i>end example</i>]</ins></p>

<h3>27.10.12.1 <a name="directory_entry-constructors"><code>directory_entry</code> 
constructors </a>[directory_entry.cons] </h3>
<pre>explicit directory_entry(const path&amp; p);
<ins>directory_entry(const path&amp; p, error_code& ec);</ins></pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type <code>directory_entry</code><ins>, 
  then <code>refresh(<i>[ec]</i>)</code></ins>.
  </p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>

<h3>27.10.12.2 <a name="directory_entry-modifiers"><code>directory_entry</code> 
modifiers </a>[directory_entry.mods] </h3>

<pre>void assign(const path&amp; p);
<ins>void assign(const path&amp; p, error_code&amp; ec);</ins></pre>
<blockquote>
  <p><ins><i>Effects:</i> <code>refresh(<i>[ec]</i>)</code>.</ins></p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>

<pre><ins>void refresh();</ins>
<ins>void refresh(error_code&amp; ec) noexcept;</ins></pre>
<blockquote>
<p><ins><i>Effects:</i>
For each data member in the table "Possibly Cached Values" above, if the data member
is implemented then set it to a value equivalent to the
result of calling the function as shown in the Equivalent Value column.
</ins></p>
<p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>

<pre>void replace_filename(const path&amp; p);</pre>
<blockquote>
  <p><i>Postcondition:</i> <code>path() == x.parent_path() / p</code> where <code>x</code> is the value of <code>path()</code> before the function is 
  called. </p>
</blockquote>
</blockquote>

<h3>27.10.12.3 <a name="directory_entry-observers"><code>directory_entry</code> observers </a>[directory_entry.obs] </h3>

<pre>const path&amp; path() const noexcept;
operator const path&amp;() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path</code> </p>
</blockquote>

<pre><ins>uintmax_t file_size() const;</ins>
<ins>uintmax_t file_size(error_code&amp; ec) const noexcept;</ins></pre>
<blockquote>
  <p><ins><i>Returns:</i> <code>m_file_size</code> if implemented,
   otherwise <code>std::filesystem::file_size(path()<i>[, ec]</i>)</code>.</ins></p>
  <p><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</p>
</blockquote>

<pre><ins>file_time_type last_write_time() const;</ins>
<ins>file_time_type last_write_time(error_code&amp; ec) const noexcept;</ins></pre>
<blockquote>
  <p><ins><i>Returns:</i> <code>m_last_write_time</code> if implemented,
   otherwise <code>std::filesystem::last_write_time(path()<i>[, ec]</i>)</code>. </p>
  <p><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins></p>
</blockquote>

<pre>file_status status() const;
file_status status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <ins><code>m_status</code> if implemented,
   otherwise</ins> <code><ins>std::filesystem::</ins>status(path()<i>[, ec]</i>)</code>. </p>
  <p><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</p>
</blockquote>

<pre>file_status  symlink_status() const;
file_status  symlink_status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
   <p><i>Returns:</i> <ins><code>m_symlink_status</code> if implemented,
   otherwise</ins> <code><ins>std::filesystem::</ins>symlink_status(path()<i>[, ec]</i>)</code>.</p>
  <p><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</p>
</blockquote>

<pre>bool operator==(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path == rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator!=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path != rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&lt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt; rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt;= rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&gt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt; rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt;= rhs.m_path</code>. </p>
</blockquote>

<h2>Proposed wording - Option 2</h2>

  <p><span style="background-color: #FFFF00"><i>Separate &lt;del&gt; wording from 
  &lt;ins&gt; wording. Moving forward now on the removal wording and later on the 
  &lt;ins&gt; wording would allow time to be sure the &lt;ins&gt; wording is fully baked.</i></span></p>

<h2>27.10.12  <a name="Class-directory_entry">Class <code>directory_entry</code></a> [class.directory_entry]</h2>

<pre>namespace std::filesystem {
  class directory_entry {
  public:
    // <a href="#directory_entry-constructors">constructors</a> and destructor
    directory_entry() noexcept = default;
    directory_entry(const directory_entry&amp;) = default;
    directory_entry(directory_entry&amp;&amp;) noexcept = default;
    explicit directory_entry(const path&amp; p);
    <ins>directory_entry(const path&amp; p, error_code& ec);</ins>
   ~directory_entry();

    // <a href="#directory_entry-modifiers">modifiers</a>
    directory_entry&amp; operator=(const directory_entry&amp;) = default;
    directory_entry&amp; operator=(directory_entry&amp;&amp;) noexcept = default;
    void assign(const path&amp; p);
    <ins>void assign(const path&amp; p, error_code&amp; ec);</ins>
    <ins>void refresh();</ins>
    <ins>void refresh(error_code&amp; ec) noexcept;</ins>
    void replace_filename(const path&amp; p);

    // <a href="#directory_entry-observers">observers</a>
    const path&amp;  path() const noexcept;
    operator const path&amp;() const noexcept;
    <del>file_status  status() const;</del>
    <del>file_status  status(error_code&amp; ec) const noexcept;</del>
    <del>file_status  symlink_status() const;</del>
    <del>file_status  symlink_status(error_code&amp; ec) const noexcept;</del>

    bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
    bool operator==(const directory_entry&amp; rhs) const noexcept;
    bool operator!=(const directory_entry&amp; rhs) const noexcept;
    bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
    bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
    bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;
  private:
    path   m_path; // for exposition only
  };

}</pre>
<p>A <code>directory_entry</code> object stores a <code>path</code> object.</p>
<p><ins>Implementations are permitted and encouraged to cache additional information 
about the state of external 
storage in <code>directory_entry</code> 
objects if such information is available during directory iteration and caching 
it would improve efficiency of  operational query functions ([fs.op.funcs]). 
Implementations are permitted and encouraged to overload  operational query functions that take <code>const path&amp;</code> arguments with 
additional signatures taking <code>const directory_entry&amp;</code> arguments. 
Such overloads shall be equivalent to ([structure.specifications]) the <code>const path&amp;</code> 
overload of the function except that state information shall be obtained from the <code>directory_entry</code> 
argument&#39;s 
cache rather than the external file system.</ins></p>
<p><ins>[<i>Note: </i>Users wishing to make use of cached <code>directory_entry</code> 
state information should call status and other operational query functions 
using the <code>directory_entry</code> object as an argument. Users wishing to 
ensure that an operational function returns the most recent available 
information should call the function with a <code>path</code> object or an 
object that is convertible to <code>path</code>. —<i>end note</i>]</ins></p>
<p><ins>[<i>Note: </i>Operational query functions that may benefit from caching 
include <code>status</code>, <code>symlink_status</code>, <code>exists</code>,
<code>is_block_file</code>, <code>is_character_file</code>, i<code>s_directory</code>,
<code>is_fifo</code>, <code>is_other</code>, <code>is_regular_file</code>, <code>
is_socket</code>, <code>is_symlink</code>, <code>status_known</code>, <code>
last_write_time</code>, and <code>file_size</code>.&nbsp; —<i>end note</i>]</ins></p>
<p><ins><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Example: TBS
</span> </i><span style="background-color: #FFFF00">—<i>end 
example</i>]</span></ins></p>

<h3>27.10.12.1 <a name="directory_entry-constructors"><code>directory_entry</code> 
constructors </a>[directory_entry.cons] </h3>
<pre>explicit directory_entry(const path&amp; p);
<ins>directory_entry(const path&amp; p, error_code& ec);</ins></pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type <code>directory_entry</code><ins>, 
  then <code>refresh(<i>[ec]</i>)</code></ins>.
  </p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>

<h3>27.10.12.2 <a name="directory_entry-modifiers"><code>directory_entry</code> 
modifiers </a>[directory_entry.mods] </h3>
<pre>void assign(const path&amp; p);
<ins>void assign(const path&amp; p, error_code&amp; ec);</ins></pre>
<blockquote>
  <p><ins><i>Effects:</i> <code>refresh(<i>[ec]</i>)</code>.</ins></p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<pre><ins>void refresh();</ins>
<ins>void refresh(error_code&amp; ec) noexcept;</ins></pre>
<blockquote>
<p><ins><i>Effects:</i> Stores current values for the 
attributes of
the file <code>p</code> resolves to in the additional information cache, if 
any.</ins></p>
<p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<pre>void replace_filename(const path&amp; p);</pre>
<blockquote>
  <p><i>Postcondition:</i> <code>path() == x.parent_path() / p</code> where <code>x</code> is the value of <code>path()</code> before the function is 
  called. </p>
</blockquote>
</blockquote>

<h3>27.10.12.3 <a name="directory_entry-observers"><code>directory_entry</code> observers </a>[directory_entry.obs] </h3>
<pre>const path&amp; path() const noexcept;
operator const path&amp;() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path</code> </p>
</blockquote>
<pre><del>file_status status() const;</del>
<del>file_status status(error_code&amp; ec) const noexcept;</del></pre>
<blockquote>
  <p><del><i>Returns:</i> <code>status(path()<i>[, ec]</i>)</code></del>. </p>
  <param><del><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</del></p>
</blockquote>
<pre><del>file_status  symlink_status() const;</del>
<del>file_status  symlink_status(error_code&amp; ec) const noexcept;</del></pre>
<blockquote>
   <p><del><i>Returns:</i> <code>symlink_status(path()<i>[, ec]</i>)</code>.</del></p>
  <p><del><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</del></p>
</blockquote>
<pre>bool operator==(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path == rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator!=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path != rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&lt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt; rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt;= rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&gt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt; rhs.m_path</code>. </p>
</blockquote>
<pre>bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt;= rhs.m_path</code>. </p>
</blockquote>


  <h2><a name="References">References</a></h2>


  <p>[1] Issue 2663, C++ Standard Library Issues Lists,
  <a href="https://cplusplus.github.io/LWG/lwg-active.html#2663">
  cplusplus.github.io/LWG/lwg-active.html#2663</a></p>

<p>[2] N4582, Working Draft, Standard for Programming Language C++, 2016,
<a class="uri" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf</a></p>

<p>[<a name="1">3</a>] Beman Dawes, N4100, Programming Languages — C++ — File System Technical Specification, 
2014.<br>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf" class="uri">
www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf</a></p>
<p>[<a name="2">4</a>] Beman Dawes, others, <a href="http://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm">Boost Filesystem Library, V3</a>, 2015.<br>
<a href="https://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm" class="uri">
www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm</a></p>

<hr>

</pre></body>

</html>