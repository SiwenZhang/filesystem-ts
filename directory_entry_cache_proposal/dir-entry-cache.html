<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Directory Entry Caching</title>
<style>
body
{
  font-family: arial, sans-serif;
  max-width: 6.75in;
  margin: 0px auto;
  font-size: 85%;
}
 ins  {background-color: #CCFFCC; text-decoration: none;}
 del  {background-color: #FFCACA; text-decoration: none;}
 pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
 code {font-size: 110%; font-family: "courier new", courier, serif;}
 table {font-size: 90%;}
</style>
</head>

<body>

<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color: #FFFF00">D0317R0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-04-12<!--webbot bot="Timestamp" endspan i-checksum="12267" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library</td>
</tr>
</table>

<h1 align="center">Directory Entry Caching for Filesystem</h1>


<p align="center"><b>Fixing issue 
<a href="https://cplusplus.github.io/LWG/lwg-active.html#2663">2663</a>, <i>Enable efficient retrieval 
of file size from <code>directory_entry</code></i></b></p>


  <h2><a name="Introduction">Introduction</a></h2>

  <p>Directory iteration in real-world operating systems returns directory 
  entries containing file name plus additional information such as file status, 
  size, and last modification date. Exactly what additional information is 
  returned varies between operating systems. Accessing the additional 
  information from the directory entry is much more efficient than re-accessing 
  the file system to obtain the information.</p>

  <p>The initial filesystem TS proposal
  <span style="background-color: #FFFF00">(need reference)</span> and the Boost 
  Filesystem implementation limited the additional information stored in a 
  directory entry to the regular status and symlink status, since these were the 
  only additional elements present for most operating systems. The caching of 
  this additional information was described using mutable exposition-only 
  members. The LWG removed the mutable members and associated caching wording 
  because mutable members are problematic and race prone in multi-threaded 
  environments. In retrospect, that original design also exposed too many implementation 
  details and was not extendible to cache information.</p>

  <p>This paper proposes a new design for caching directory entries that exposes no 
  implementation details beyond the fact that there may be a cache. It is 
  extendible by implementations to cache additional information without any need 
  for changes in user code or the standard library. It makes minimal 
  changes to existing interfaces and implementations.</p>

  <p>LWG issue 2663, <i>[filesys.ts] Enable efficient retrieval of 
  file size from </i><code><i>directory_entry</i></code>, requests that for 
  Windows caching be extended to file size. Although this request was made 
  before the LWG removed caching, it is indicative of the desire to maximize 
  efficiency for particular operating systems. Subsequent to the removal of 
  directory entry caching and addition of Filesystem to the standard library, a
  <span style="background-color: #FFFF00">new issue</span> has been submitted 
  asking for the reinstatement of caching.</p>

  <h2>Design</h2>

  <p>As a convenience for users, class <code>directory_entry</code> 
  already has an implicit conversion to <code>path</code>:</p>

  <blockquote>
    <p><code>operator const path&amp;() const noexcept;</code></p>
</blockquote>

    <p>This means that the following two function calls are equivalent:</p>

  <blockquote>

    <p><code>sz = file_size(my_directory_entry);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    // call #1<br>
    sz = file_size(my_directory_entry.path());&nbsp; // call #2</code></p>

  </blockquote>

    <p>Both would currently call the non-member function:</p>

  <blockquote>

    <p><code>uintmax_t file_size(const path&amp; p);</code></p>

  </blockquote>

    <p>But if there were a second signature: </p>

  <blockquote>

    <p><code>uintmax_t file_size(const directory_entry&amp; d);</code></p>

  </blockquote>

    <p>It would be invoked by call #1, and the implementation could provide the 
    file size from information cached in <code>d</code>. Guidance to users would 
    be to use call #1 when the possibly cached&nbsp; <code>directory_entry</code> file size is desired, 
    use call #2 when file size from a file system access is desired. For 
    implementations where file size is not cached in directory 
    entries, both call forms access the file system to obtain the file size.</p>

    <h3>Specification options</h3>

    <p>There are two possible ways to specify the above behavior; (1) require the <code>const 
    directory_entry&amp;</code> overload for all operational functions that 
    might possibly benefit from it, either now and in the future, or (2) provide 
    overall wording to encourage the implementation to supply the <code>const 
    directory_entry&amp;</code> overload where applicable, but make no changes 
    to the specifications of individual operational functions .</p>

    <p>The 
    difficulty with option (1) is that it essentially doubles the number of 
    operational function signatures, making the operational functions harder to 
    learn, even though few of these added signatures will do anything more than 
    forward to the <code>const path&amp;</code>&nbsp; signature. Option (2) 
    segregates what is essentially an experts-only feature into its own separate 
    specification, and is what is being proposed below.</p>

  <h2>Proposed wording</h2>

  <p><span style="background-color: #FFFF00"><i>Separate &lt;del&gt; wording from 
  &lt;ins&gt; wording. Moving forward now on the removal wording and later on the 
  &lt;ins&gt; wording would allow time to be sure the &lt;ins&gt; wording is fully baked.</i></span></p>

<h2>27.10.12  <a name="Class-directory_entry">Class <code>directory_entry</code></a> [class.directory_entry]</h2>

<pre>namespace std::filesystem {
  class directory_entry {
  public:
    // <a href="#directory_entry-constructors">constructors</a> and destructor
    directory_entry() noexcept = default;
    directory_entry(const directory_entry&amp;) = default;
    directory_entry(directory_entry&amp;&amp;) noexcept = default;
    explicit directory_entry(const path&amp; p);
    <ins>directory_entry(const path&amp; p, error_code& ec);</ins>
   ~directory_entry();

    // <a href="#directory_entry-modifiers">modifiers</a>
    directory_entry&amp; operator=(const directory_entry&amp;) = default;
    directory_entry&amp; operator=(directory_entry&amp;&amp;) noexcept = default;
    void assign(const path&amp; p);
    <ins>void assign(const path&amp; p, error_code&amp; ec);</ins>
    <ins>void refresh();</ins>
    <ins>void refresh(error_code&amp; ec) noexcept;</ins>
    void replace_filename(const path&amp; p);

    // <a href="#directory_entry-observers">observers</a>
    const path&amp;  path() const noexcept;
    operator const path&amp;() const noexcept;
    <del>file_status  status() const;</del>
    <del>file_status  status(error_code&amp; ec) const noexcept;</del>
    <del>file_status  symlink_status() const;</del>
    <del>file_status  symlink_status(error_code&amp; ec) const noexcept;</del>

    bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
    bool operator==(const directory_entry&amp; rhs) const noexcept;
    bool operator!=(const directory_entry&amp; rhs) const noexcept;
    bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
    bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
    bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;
  private:
    path   m_path; // for exposition only
  };

}</pre>
<p>A <code>directory_entry</code> object stores a <code>path</code> object.</p>
<p><ins>Implementations are permitted and encouraged to cache additional information in <code>directory_entry</code> 
objects if such information is available during directory iteration and doing so would improve efficiency of status and other operational query functions. 
Implementations are permitted and encouraged to overload status and other 
operational query functions that take <code>const path&amp;</code> arguments with 
additional signatures taking <code>const directory_entry&amp;</code> arguments and 
satisfy the status or other operational query from the <code>directory_entry</code> 
argument&#39;s 
cache.</ins></p>
<p><ins>[<i>Note: </i>Users wishing to make use of cached <code>directory_entry</code> 
additional information should call status and other operational query functions 
using the <code>directory_entry</code> object as an argument. Users wishing to 
ensure that an operational function returns the most recent available 
information should call the function with a <code>path</code> object or an 
object that is convertible to <code>path</code>. —<i>end note</i>]</ins></p>
<p><ins>[<i>Note: </i>Operational query functions that may benefit from caching 
include <code>status</code>, <code>symlink_status</code>, <code>exists</code>,
<code>is_block_file</code>, <code>is_character_file</code>, i<code>s_directory</code>,
<code>is_fifo</code>, <code>is_other</code>, <code>is_regular_file</code>, <code>
is_socket</code>, <code>is_symlink</code>, <code>status_known</code>, <code>
last_write_time</code>, and <code>file_size</code>.&nbsp; —<i>end note</i>]</ins></p>
<p><ins>[<i>Example: <span style="background-color: #FFFF00">TBS</span> </i>—<i>end 
example</i>]</ins></p>
<h3>27.10.12.1 <a name="directory_entry-constructors"><code>directory_entry</code> 
constructors </a>[directory_entry.cons] </h3>
<pre>explicit directory_entry(const path&amp; p);
<ins>directory_entry(const path&amp; p, error_code& ec);</ins></pre>
<blockquote>
  <p><i>Effects: </i>Constructs an object of type <code>directory_entry</code><ins>, 
  then <code>refresh(<i>[ec]</i>)</code></ins>.
  </p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<h3>27.10.12.2 <a name="directory_entry-modifiers"><code>directory_entry</code> 
modifiers </a>[directory_entry.mods] </h3>
<pre>void assign(const path&amp; p);
<ins>void assign(const path&amp; p, error_code&amp; ec);</ins></pre>
<blockquote>
  <p><ins><i>Effects:</i> <code>refresh(<i>[ec]</i>)</code>.</ins></p>
  <p><i>Postcondition:</i> <code>path() == p</code>.</p>
  <p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<pre><ins>void refresh();</ins>
<ins>void refresh(error_code&amp; ec) noexcept;</ins></pre>
<blockquote>
<p><ins><i>Effects:</i> Stores current values for the 
attributes of
the file <code>p</code> resolves to in the additional information cache, if 
any.</ins></p>
<p><ins><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</ins> </p>
</blockquote>
<pre>void replace_filename(const path&amp; p);</pre>
<blockquote>
  <p><i>Postcondition:</i> <code>path() == x.parent_path() / p</code> where <code>x</code> is the value of <code>path()</code> before the function is 
  called. </p>
</blockquote>
</blockquote>
<h3>27.10.12.3 <a name="directory_entry-observers"><code>directory_entry</code> observers </a>[directory_entry.obs] </h3>
<pre>const path&amp; path() const noexcept;
operator const path&amp;() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path</code> </p>
</blockquote>
<pre><del>file_status status() const;</del>
<del>file_status status(error_code&amp; ec) const noexcept;</del></pre>
<blockquote>
  <p><del><i>Returns:</i> <code>status(path()<i>[, ec]</i>)</code></del>. </p>
  <p para_num="5"><del><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</del></p>
</blockquote>
<pre para_num="6"><del>file_status  symlink_status() const;</del>
<del>file_status  symlink_status(error_code&amp; ec) const noexcept;</del></pre>
<blockquote>
   <p para_num="7"><del><i>Returns:</i> <code>symlink_status(path()<i>[, ec]</i>)</code>.</del></p>
  <p para_num="8"><del><i>Throws:</i> As specified in Error 
  reporting ([fs.err.report]).</del></p>
</blockquote>
<pre para_num="9">bool operator==(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="10"><i>Returns:</i> <code>m_path == rhs.m_path</code>. </p>
</blockquote>
<pre para_num="11">bool operator!=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="12"><i>Returns:</i> <code>m_path != rhs.m_path</code>. </p>
</blockquote>
<pre para_num="13">bool operator&lt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="14"><i>Returns:</i> <code>m_path &lt; rhs.m_path</code>. </p>
</blockquote>
<pre para_num="15">bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="16"><i>Returns:</i> <code>m_path &lt;= rhs.m_path</code>. </p>
</blockquote>
<pre para_num="17">bool operator&gt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="18"><i>Returns:</i> <code>m_path &gt; rhs.m_path</code>. </p>
</blockquote>
<pre para_num="19">bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p para_num="20"><i>Returns:</i> <code>m_path &gt;= rhs.m_path</code>. </p>
</blockquote>


  <h2><a name="References">References</a></h2>


  <p>[1] Issue 2663, C++ Standard Library Issues Lists,
  <a href="https://cplusplus.github.io/LWG/lwg-active.html#2663">
  cplusplus.github.io/LWG/lwg-active.html#2663</a></p>

<p>[2] N4582, Working Draft, Standard for Programming Language C++, 2016,
<a class="uri" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf</a></p>

<p>[<a name="1">3</a>] Beman Dawes, N4100, Programming Languages — C++ — File System Technical Specification, 
2014.<br>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf" class="uri">
www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf</a></p>
<p>[<a name="2">4</a>] Beman Dawes, others, <a href="http://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm">Boost Filesystem Library, V3</a>, 2015.<br>
<a href="https://www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm" class="uri">
www.boost.org/doc/libs/1_60_0/libs/filesystem/doc/index.htm</a></p>

<hr>

</pre></body>

</html>